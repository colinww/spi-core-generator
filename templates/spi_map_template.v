/*
 * spi_map.v
 * This file is auto-generated by the make_spi.py script from the spi
 * register map.
 */

module spi_map(
	       // Inputs
	       i_rstb, i_spi_active, vi_data_rx, i_rx_valid, vi_byte_num,
	       // Read-only inputs
	       // INSERT_RO
	       // Write-only outputs
	       // INSERT_WO
	       // Registered outputs
	       // INSERT_RW
	       // Outputs
	       vio_data_spi);
  // Global reset
  input 	i_rstb;
  // Data from SPI interface
  input 	i_spi_active;
  input [7:0] 	vi_data_rx;
  input 	i_rx_valid;
  input [2:0] 	vi_byte_num;
  // Data to SPI interface
  inout [7:0] 	vio_data_spi;
  // Static registered outputs (rw)
  // INSERT_RW_DECLARATION
  // Shadow register read-only inputs (ro)
  // INSERT_RO_DECLARATION
  // Pulsed write-only outputs (wo)
  // INSERT_WO_DECLARATION
  // Latched data to be sent back
  reg [7:0] 	r_data_to_send;
  /*
   * Create a local reset signal that is used for state machine registers
   */
  wire active = i_rstb && i_spi_active;
  /*
   * Latch in the opcode, which is byte 0 of the data
   * If reading from the map, drive the data bus to the SPI during byte 2
   * Latch in the address, which is byte 1 of the data
   */
  reg [7:0] 	rv_opcode;
  reg 		r_read_map;
  reg 		r_write_map;
  reg [7:0] 	rv_addr;
  always @( posedge i_rx_valid or negedge active ) begin : opcode_fsm
    if ( !active ) begin
      rv_opcode <= 0;
      r_read_map <= 0;
      r_write_map <= 0;
      rv_addr <= 0;
    end else begin
      // Load opcode
      if ( 0 == vi_byte_num )
	rv_opcode <= vi_data_rx;
      // Load address
      if ( 1 == vi_byte_num )
	rv_addr <= vi_data_rx;
      // Determine what to do after address is received
      if ( 1 == vi_byte_num ) begin
	if ( 32 == rv_opcode )
	  r_write_map <= 1;
	else
	  r_write_map <= 0;
	if ( 48 == rv_opcode )
	  r_read_map <= 1;
	else
	  r_read_map <= 0;
      end
    end // else: !if( !active )
  end // block: opcode_fsm
  /*
   * All the registered fields are written in this section.
   */
  always @( posedge i_rx_valid or negedge i_rstb ) begin
    if ( !i_rstb ) begin
      // INSERT_RESET_REGS
    end else begin
      // INSERT_WRITE_REGS
    end
  end 
  /*
   * All the write-only outputs which are passed through are in this section.
   */
  // INSERT_PULSE_DECLARATION
  always @( posedge i_rx_valid or negedge active ) begin
    if ( !active ) begin
      // INSERT_PULSE_RESET
    end else begin
      if (( 2 == vi_byte_num ) && (r_write_map )) begin
	// INSERT_PULSE_REG
      end
    end
  end
  // INSERT_WRITE_WIRES
  /*
   * All the reading is handled here, both from registered fields and shadowed data.
   */
  // Combinationl logic that indicates from which register data is being read
  // INSERT_READ_WIRES
  // Data is read on rising edge of second rx_valid pulse (byte 1)
  always @( posedge i_rx_valid or negedge active ) begin
    if ( !active ) begin
      r_data_to_send <= 0;
    end else begin
      // INSERT_READ_REGS
    end
  end
  /*
   * Only drive the bus when reading from the map, during byte 2.
   */
  assign vio_data_spi = r_read_map ? r_data_to_send : 8'bz;
endmodule // spi_map